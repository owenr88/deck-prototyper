{"version":3,"sources":["types/index.ts","styles/theme.ts","data/queries/cards.ts","data/queries/decks.ts","data/DataContext/DataContext.tsx","data/queries/has-imported.ts","data/factories/decks.ts","data/factories/cards.ts","data/DataContext/index.ts","data/DrawerContext/DrawerContext.tsx","data/DrawerContext/index.ts","components/Nav/NavComponent.tsx","components/Nav/index.ts","utils/color.js","components/Card/CardBase/CardBaseComponent.tsx","components/Card/CardBase/index.ts","components/Card/CardEmpty/CardEmptyComponent.tsx","components/Card/CardEmpty/index.ts","components/Card/CardBack/CardBackComponent.tsx","components/Card/CardBack/index.ts","components/Card/CardFront/CardFrontComponent.tsx","components/Card/CardFront/index.ts","hooks/useWindowSize.tsx","components/Deck/DeckComponent.tsx","components/Deck/index.ts","components/NoDecks/NoDecksComponent.tsx","components/NoDecks/index.ts","components/CardPreviewer/CardPreviewerComponent.tsx","components/CardPreviewer/index.ts","components/Drawer/DecksDrawer/DecksDrawerComponent.tsx","components/Drawer/DecksDrawer/index.ts","components/Drawer/CardsDrawer/CardsDrawerComponent.tsx","components/Drawer/CardsDrawer/index.ts","hooks/useImport.tsx","hooks/useExport.tsx","components/Settings/SettingsComponent.tsx","components/Settings/index.ts","scenes/Main/MainScene.tsx","serviceWorker.ts","index.tsx","styles/colors.js"],"names":["ConfigPages","primary","colors","secondary","possibleDeckColors","lightBlue","lightOrange","red","orange","theme","gradientColors","blue","nav","navStrong","card","height","cardWidth","width","margin","saveCards","cards","localStorage","setItem","JSON","stringify","saveDecks","decks","Context","React","createContext","fetching","hasImported","getCardDeckNames","getCardsByDeck","findDeck","generateRandomData","refetchFromLocalStorage","changeHasImported","updateDeckField","updateCardField","createDeck","createCard","DataContextProvider","children","useState","setFetching","setCards","setDecks","setHasImported","fetchHasImported","data","getItem","parse","getHasImportedOwnCards","imported","value","useEffect","deckId","find","d","number","getDecks","getCards","Provider","decksToSearch","map","title","filter","Boolean","deck","fullDeck","times","flatten","total","i","description","faker","lorem","sentence","color","random","arrayElement","makeDecks","deckData","sampleSize","length","forEach","words","body1","body2","makeCards","field","index","findIndex","Error","push","DataContext","pages","hasPage","togglePage","DrawerContextProvider","setPages","page","undefined","includes","without","DrawerContext","Top","styled","div","open","IconItem","NavComponent","useContext","DATA","BookOutlined","onClick","DECKS","OrderedListOutlined","SettingOutlined","SETTINGS","placement","onConfirm","onCancel","okText","cancelText","QuestionCircleOutlined","getCorrectTextColor","hex","black","chroma","contrast","CardStyledBasic","Card","props","Title","Typography","CardBase","textColor","bordered","level","CardEmptyStyled","$marginTop","CardEmpty","onReshuffle","marginTop","type","CardBackStyled","Text","Paragraph","$textColor","CardBack","numberOfCards","cardsByDeck","CardFrontStyled","Number","CardFront","useWindowHeight","window","innerHeight","setHeight","handleResize","addEventListener","removeEventListener","useWindowWidth","innerWidth","setWidth","TextStyled","Wrapper","DeckComponent","cardMarginTop","setCardMarginTop","cardsInDeck","setCardsInDeck","cardsDiscarded","setCardsDiscarded","refillDeck","useCallback","containerHeight","cardHeight","expectedMarginTop","withMaximum","min","withMinimum","max","href","removedCards","splice","last","NoDecksStyled","NoDecks","role","aria-label","SliderStyled","Slider","CardPreviewer","toShow","setToShow","containerWidth","totalDecks","maxDecks","Math","floor","newToShow","settings","infinite","dots","speed","autoplay","slidesToShow","slidesToScroll","initialSlide","Deck","key","ColorPickerWrapper","ColorDotStyled","clicked","dotColor","BlockPickerWrapper","ListItemStyled","List","Item","DeckDrawerListItem","numberColorPicker","toggleNumberColorPicker","setClicked","totalCards","Meta","editable","onChange","avatar","style","backgroundColor","triangle","DecksDrawer","setNumberColorPicker","newDeck","setNewDeck","no","closable","visible","onClose","maskClosable","mask","dataSource","renderItem","footer","e","target","placeholder","addonAfter","EnterOutlined","onPressEnter","preventDefault","message","error","TagStyled","Tag","SearchStyled","Input","Search","DrawerCards","searchQuery","setSearchQuery","columns","dataIndex","render","id","toString","deckNumbers","icon","MinusCircleOutlined","removeFromDeck","closeIcon","PlusCircleOutlined","addToDeck","toUpperCase","searchedCards","regex","RegExp","test","onSearch","allowClear","clear","expectedFields","requiredFields","parseCSV","file","Promise","resolve","reject","Papa","skipEmptyLines","header","complete","validateFields","results","headers","meta","fields","missingHeaders","join","row","formatCards","parseInt","split","checkUniqueIds","allIds","c","uniq","useImport","importing","setImporting","createDecksFromImportedCards","deckNames","reduce","all","deckName","usedColors","saveDecksAndCards","cardData","decksRelationship","deckNameAndNumber","importFile","a","validatedData","console","transformCardDecksToString","Object","keys","name","useExport","exporting","setExporting","exportData","cardsContent","unparse","encodedCardsUri","encodeURI","FooterText","Settings","showMore","setShowMore","handleExport","success","handleImport","info","onSuccess","onError","onOk","rel","Dragger","accept","multiple","customRequest","showUploadList","className","ImportOutlined","process","download","Page","Layout","col1","rgb","col2","col3","col4","Container","Content","App","Nav","CardsDrawer","location","hostname","match","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","module","exports"],"mappings":"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","file":"static/js/main.adbde0da.chunk.js","sourcesContent":["export enum ConfigPages {\n  DECKS,\n  DATA,\n  SETTINGS,\n}\n\nexport interface CardDecks {\n  [key: number]: number;\n}\n\nexport interface CardType {\n  number: number;\n  title?: string;\n  body1?: string;\n  body2?: string;\n  decks: CardDecks;\n}\n\nexport interface DeckType {\n  number: number;\n  title: string;\n  description: string;\n  color?: string;\n}\n","import { DefaultTheme } from 'styled-components';\n\nimport colors from './colors';\n\nconst primary = colors.primary;\nconst secondary = colors.secondary;\n\nexport const possibleDeckColors = [\n  primary,\n  secondary,\n  colors.lightBlue,\n  colors.lightOrange,\n  colors.red,\n  colors.orange,\n];\n\nexport const cardWidth = 200;\nexport const cardHeight = cardWidth * 1.4;\n\nconst theme: DefaultTheme = {\n  colors: {\n    primary,\n    secondary,\n    possibleDeckColors,\n    gradientColors: [primary, colors.blue, colors.secondary, secondary],\n    nav: 'rgba(255,255,255,0.1)',\n    navStrong: 'rgba(255,255,255,0.5)',\n  },\n  card: {\n    height: `${cardHeight}px`,\n    width: `${cardWidth}px`,\n    margin: '15px',\n  },\n};\n\nexport default theme;\n","import { CardType } from '../../types';\n\nconst CARDS_LS_KEY = 'deck-prototyper-cards-data';\n\nexport const saveCards = (cards: CardType[]) => {\n  return localStorage.setItem(CARDS_LS_KEY, JSON.stringify(cards));\n};\n\nexport const getCards = (): CardType[] => {\n  const data = localStorage.getItem(CARDS_LS_KEY);\n  if (!data) return [];\n  return JSON.parse(data) as CardType[];\n};\n\nexport const addCard = (card: CardType): void => {};\nexport const removeCard = (card: CardType): void => {};\nexport const updateCard = (card: CardType): void => {};\n","import { DeckType } from '../../types';\n\nconst DECKS_LS_KEY = 'deck-prototyper-decks-data';\n\nexport const saveDecks = (decks: DeckType[]) => {\n  return localStorage.setItem(DECKS_LS_KEY, JSON.stringify(decks));\n};\n\nexport const getDecks = (): DeckType[] => {\n  const data = localStorage.getItem(DECKS_LS_KEY);\n  if (!data) return [];\n  return JSON.parse(data) as DeckType[];\n};\n\nexport const removeDeck = (deck: DeckType): void => {};\nexport const updateDeck = (deck: DeckType): void => {};\n","import React, { useState, useEffect } from 'react';\nimport { times, flatten } from 'lodash';\n\nimport { CardType, DeckType } from '../../types';\n\nimport { getCards, saveCards } from '../queries/cards';\nimport { getDecks, saveDecks } from '../queries/decks';\nimport { makeDecks } from '../factories/decks';\nimport { makeCards } from '../factories/cards';\nimport {\n  getHasImportedOwnCards,\n  saveHasImportedOwnCards,\n} from '../queries/has-imported';\n\ninterface ProviderProps {\n  children?: React.ReactNode;\n}\n\ninterface CardContextProps {\n  cards: CardType[];\n  decks: DeckType[];\n  fetching: boolean;\n  hasImported: boolean;\n  getCardDeckNames: (decksToSearch?: number[]) => string[];\n  getCardsByDeck: (deck: DeckType) => CardType[];\n  findDeck: (deckId: number) => DeckType | undefined;\n  generateRandomData: () => void;\n  refetchFromLocalStorage: () => void;\n  changeHasImported: (value: boolean) => void;\n  updateDeckField: (number: number, field: string, value: any) => void;\n  updateCardField: (number: number, field: string, value: any) => void;\n  createDeck: (deck: DeckType) => void;\n  createCard: (card: CardType) => void;\n}\n\nconst Context = React.createContext<CardContextProps>({\n  cards: [],\n  decks: [],\n  fetching: true,\n  hasImported: false,\n  getCardDeckNames: () => [],\n  getCardsByDeck: () => [],\n  findDeck: () => undefined,\n  generateRandomData: () => {},\n  refetchFromLocalStorage: () => {},\n  changeHasImported: () => {},\n  updateDeckField: () => {},\n  updateCardField: () => {},\n  createDeck: () => {},\n  createCard: () => {},\n});\n\nconst DataContextProvider: React.FC<ProviderProps> = ({ children }) => {\n  const [fetching, setFetching] = useState<boolean>(true);\n  const [cards, setCards] = useState<CardType[]>([]);\n  const [decks, setDecks] = useState<DeckType[]>([]);\n  const [hasImported, setHasImported] = useState<boolean>(false);\n\n  const fetchHasImported = () => {\n    setHasImported(getHasImportedOwnCards());\n  };\n\n  const changeHasImported = (imported: boolean) => {\n    saveHasImportedOwnCards(imported);\n    setHasImported(imported);\n  };\n\n  useEffect(() => {\n    refetchFromLocalStorage();\n    fetchHasImported();\n  }, []);\n\n  const getCardDeckNames = (decksToSearch?: number[]) =>\n    decksToSearch\n      ?.map((number) => findDeck(number)?.title ?? '')\n      .filter(Boolean) ?? [];\n\n  const findDeck = (deckId?: number): DeckType | undefined =>\n    decks.find((d) => d.number === deckId);\n\n  const getCardsByDeck = (deck: DeckType) => {\n    const fullDeck = cards\n      .filter((card) => deck.number in card.decks)\n      .map((card) => {\n        return times(card.decks[deck.number], () => card);\n      });\n    return flatten(fullDeck);\n  };\n\n  const generateRandomData = () => {\n    setFetching(true);\n    const decks = makeDecks(5);\n    saveDecks(decks);\n    setDecks(decks);\n    const cards = makeCards(20, decks);\n    saveCards(cards);\n    setCards(cards);\n    setFetching(false);\n    changeHasImported(false);\n    return cards;\n  };\n\n  const refetchFromLocalStorage = () => {\n    setFetching(true);\n    setDecks(getDecks());\n    setCards(getCards());\n    setFetching(false);\n  };\n\n  const updateDeckField = (number: number, field: string, value: any) => {\n    const index = decks.findIndex((d) => d.number === number);\n    if (index === -1) throw new Error(\"Deck doesn't exist\");\n    decks[index] = {\n      ...decks[index],\n      [field]: value,\n    };\n    saveDecks(decks);\n    refetchFromLocalStorage();\n  };\n\n  const updateCardField = (number: number, field: string, value: any) => {\n    const index = cards.findIndex((d) => d.number === number);\n    if (index === -1) throw new Error(\"Card doesn't exist\");\n    cards[index] = {\n      ...cards[index],\n      [field]: value,\n    };\n    saveCards(cards);\n    refetchFromLocalStorage();\n  };\n\n  const createCard = (card: CardType) => {\n    cards.push(card);\n    saveCards(cards);\n    refetchFromLocalStorage();\n  };\n\n  const createDeck = (deck: DeckType) => {\n    decks.push(deck);\n    saveDecks(decks);\n    refetchFromLocalStorage();\n  };\n\n  return (\n    <Context.Provider\n      value={{\n        cards,\n        decks,\n        fetching,\n        hasImported,\n        getCardDeckNames,\n        getCardsByDeck,\n        findDeck,\n        generateRandomData,\n        refetchFromLocalStorage,\n        changeHasImported,\n        updateDeckField,\n        updateCardField,\n        createDeck,\n        createCard,\n      }}\n    >\n      {children}\n    </Context.Provider>\n  );\n};\n\nexport default Context;\nexport { DataContextProvider };\n","const IMPORTED_OWN_CARDS = 'deck-prototyper-imported-own-cards';\n\nexport const getHasImportedOwnCards = (): boolean => {\n  const data = localStorage.getItem(IMPORTED_OWN_CARDS);\n  if (!data) return false;\n  return JSON.parse(data) as boolean;\n};\n\nexport const saveHasImportedOwnCards = (value: boolean): void => {\n  return localStorage.setItem(IMPORTED_OWN_CARDS, JSON.stringify(value));\n};\n","import { times } from 'lodash';\nimport faker from 'faker';\n\nimport { DeckType } from '../../types';\nimport { possibleDeckColors } from '../../styles/theme';\n\nexport const makeDecks = (total: number = 1): DeckType[] => {\n  return times(total, (i) => ({\n    number: i + 1,\n    title: `Deck ${i + 1}`,\n    description: faker.lorem.sentence(),\n    color: faker.random.arrayElement(possibleDeckColors),\n  }));\n};\n","import { times, sampleSize, random } from 'lodash';\nimport faker from 'faker';\n\nimport { CardType, DeckType, CardDecks } from '../../types';\n\nexport const makeCards = (total: number = 1, decks: DeckType[]): CardType[] => {\n  return times(total, (i) => {\n    let deckData: CardDecks = {};\n    sampleSize(decks, random(0, decks.length)).forEach((d) => {\n      deckData[d.number] = random(1, 2);\n    });\n    return {\n      number: i + 1,\n      title: i + ': ' + faker.lorem.words(3),\n      body1: faker.lorem.sentence(),\n      body2: faker.lorem.sentence(),\n      decks: deckData,\n    };\n  });\n};\n","import DataContext, { DataContextProvider } from './DataContext';\nexport default DataContext;\nexport { DataContextProvider };\n","import React, { useState } from 'react';\nimport { without } from 'lodash';\n\nimport { ConfigPages } from '../../types';\n\ninterface ProviderProps {\n  children?: React.ReactNode;\n}\n\ninterface CardContextProps {\n  pages: ConfigPages[];\n  hasPage: (page: ConfigPages) => boolean;\n  togglePage: (page: ConfigPages) => void;\n}\n\nconst Context = React.createContext<CardContextProps>({\n  pages: [],\n  hasPage: () => false,\n  togglePage: () => {},\n});\n\nconst DrawerContextProvider: React.FC<ProviderProps> = ({ children }) => {\n  const [pages, setPages] = useState<ConfigPages[]>([]);\n\n  const hasPage = (page?: ConfigPages) =>\n    page !== undefined && pages.includes(page);\n\n  const togglePage = (page?: ConfigPages) => {\n    if (page === undefined) return;\n    if (!ConfigPages[page]) return;\n    if (hasPage(page)) {\n      setPages(without(pages, page));\n    } else {\n      setPages([...pages, page]);\n    }\n  };\n\n  return (\n    <Context.Provider\n      value={{\n        pages,\n        hasPage,\n        togglePage,\n      }}\n    >\n      {children}\n    </Context.Provider>\n  );\n};\n\nexport default Context;\nexport { DrawerContextProvider };\n","import DrawerContext, { DrawerContextProvider } from './DrawerContext';\nexport default DrawerContext;\nexport { DrawerContextProvider };\n","import React, { useContext } from 'react';\nimport styled from 'styled-components';\nimport {\n  OrderedListOutlined,\n  SettingOutlined,\n  QuestionCircleOutlined,\n  BookOutlined,\n} from '@ant-design/icons';\nimport { Tooltip, Popconfirm } from 'antd';\n\nimport { ConfigPages } from '../../types';\nimport DrawerContext from '../../data/DrawerContext';\nimport DataContext from '../../data/DataContext';\n\ntype TopProps = {\n  open: boolean;\n};\n\nconst Top = styled.div<TopProps>`\n  position: fixed;\n  bottom: 30px;\n  left: auto;\n  right: auto;\n  z-index: 10;\n  display: flex;\n  flex-direction: row;\n  transition: background 1s;\n  background: ${({ theme, open }) => theme.colors.nav};\n  padding: 0 20px;\n  border-radius: 20px;\n`;\n\nconst IconItem = styled.div`\n  padding: 20px;\n  flex: 1;\n`;\n\ninterface NavProps {}\n\nconst NavComponent: React.FC<NavProps> = () => {\n  const { hasPage, togglePage } = useContext(DrawerContext);\n  const { generateRandomData, hasImported } = useContext(DataContext);\n\n  return (\n    <Top open={hasPage(ConfigPages.DATA)}>\n      <IconItem>\n        <BookOutlined onClick={() => togglePage(ConfigPages.DECKS)} />\n      </IconItem>\n      <IconItem>\n        <OrderedListOutlined onClick={() => togglePage(ConfigPages.DATA)} />\n      </IconItem>\n      <IconItem>\n        <SettingOutlined onClick={() => togglePage(ConfigPages.SETTINGS)} />\n      </IconItem>\n      <IconItem>\n        <Tooltip title=\"Generate random data\" placement=\"top\">\n          {hasImported ? (\n            <Popconfirm\n              title=\"Generating random data will override any data you imported already. Are you sure?\"\n              onConfirm={() => generateRandomData()}\n              onCancel={() => {}}\n              okText=\"Yes\"\n              cancelText=\"No\"\n              // disabled={!importedOwnCards}\n            >\n              <QuestionCircleOutlined />\n            </Popconfirm>\n          ) : (\n            <QuestionCircleOutlined onClick={() => generateRandomData()} />\n          )}\n        </Tooltip>\n      </IconItem>\n    </Top>\n  );\n};\n\nexport default NavComponent;\n","import NavComponent from './NavComponent';\nexport default NavComponent;\n","import chroma from 'chroma-js'\n\nexport const getCorrectTextColor = (hex) => {\n\n  const black = 'rgba(0, 0, 0, 0.85)';\n  const white = '#FFFFFF';\n\n  if( chroma.contrast(hex, black) > 4.5 ) {\n    return black;\n  } else { return white}\n\t\t\n  /*\n  From this W3C document: http://www.webmasterworld.com/r.cgi?f=88&d=9769&url=http://www.w3.org/TR/AERT#color-contrast\n  \n  Color brightness is determined by the following formula: \n  ((Red value X 299) + (Green value X 587) + (Blue value X 114)) / 1000\n  \n  I know this could be more compact, but I think this is easier to read/explain.\n  \n  */\n  \n  // let threshold = 130; /* about half of 256. Lower threshold equals more dark text on dark background  */\n  \n  // let hRed = hexToR(hex);\n  // let hGreen = hexToG(hex);\n  // let hBlue = hexToB(hex);\n  \n  \n  // function hexToR(h) {return parseInt((cutHex(h)).substring(0,2),16)}\n  // function hexToG(h) {return parseInt((cutHex(h)).substring(2,4),16)}\n  // function hexToB(h) {return parseInt((cutHex(h)).substring(4,6),16)}\n  // function cutHex(h) {return (h.charAt(0)=='#') ? h.substring(1,7):h}\n\n  // let cBrightness = ((hRed * 299) + (hGreen * 587) + (hBlue * 114)) / 1000;\n  // if (cBrightness > threshold){return '#000000';} else { return '#ffffff';}\t\n}\n","import React from 'react';\nimport { Card, Typography } from 'antd';\nimport styled, { DefaultTheme } from 'styled-components';\n\nconst CardStyledBasic = styled(Card)`\n  height: ${(props) => props.theme.card.height};\n  width: ${(props) => props.theme.card.width};\n  margin: ${(props) => props.theme.card.margin};\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n`;\n\ninterface TitleStyledprops {\n  color: string;\n  theme: DefaultTheme;\n}\n\nconst Title = styled(Typography.Title)<TitleStyledprops>`\n  ${(props) => props.color && 'color: ' + props.color + '!important'};\n`;\n\n// interface CardBasicProps {\n//   children?: React.ReactNode;\n// }\n\nconst CardBasic: React.FC<any> = ({ children, title, textColor, ...props }) => {\n  return (\n    <CardStyledBasic bordered={false} {...props}>\n      <Title level={3} color={textColor}>\n        {title}\n      </Title>\n      {children}\n    </CardStyledBasic>\n  );\n};\n\nexport default CardBasic;\n","import CardBase from './CardBaseComponent';\nexport default CardBase;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { Button } from 'antd';\n\nimport CardBase from '../CardBase';\n\ninterface CardEmptyStyledProps {\n  $marginTop: number;\n}\n\nconst CardEmptyStyled = styled(CardBase)<CardEmptyStyledProps>`\n  background: rgba(255, 255, 255, 0.3);\n  z-index: ${(props) => (props.$marginTop < 0 ? -2 : 0)};\n  ${(props) =>\n    props.$marginTop < 0 ? `margin-top: ${props.$marginTop}px` : ''};\n`;\n\ninterface CardEmptyProps {\n  title?: string;\n  marginTop?: number;\n  onReshuffle?: () => void;\n}\n\nconst CardEmpty: React.FC<CardEmptyProps> = ({\n  title,\n  onReshuffle,\n  marginTop,\n}) => {\n  return (\n    <CardEmptyStyled title={title || 'No cards'} $marginTop={marginTop}>\n      {!!onReshuffle && (\n        <>\n          <Button type=\"primary\" onClick={() => onReshuffle()}>\n            Reshuffle?\n          </Button>\n        </>\n      )}\n    </CardEmptyStyled>\n  );\n};\n\nexport default CardEmpty;\n","import CardEmpty from './CardEmptyComponent';\nexport default CardEmpty;\n","import React, { useContext } from 'react';\nimport styled from 'styled-components';\nimport { Typography } from 'antd';\n\nimport { DeckType } from '../../../types';\nimport { getCorrectTextColor } from '../../../utils/color';\nimport DataContext from '../../../data/DataContext';\n\nimport CardBase from '../CardBase';\nimport CardEmpty from '../CardEmpty';\n\ninterface CardBackStylesProps {\n  deck?: DeckType;\n}\n\nconst CardBackStyled = styled(CardBase)<CardBackStylesProps>`\n  background: ${(props) => props.deck?.color || '#f9fbef'};\n  cursor: pointer;\n  border: 2px solid #f9fbef;\n`;\n\ninterface TextProps {\n  $textColor: string;\n}\n\nconst Text = styled(Typography.Paragraph)<TextProps>`\n  color: ${(props) => props.$textColor};\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n`;\n\ninterface CardBackProps {\n  deck?: DeckType;\n  onClick: () => void;\n  numberOfCards: number;\n}\n\nconst CardBack: React.FC<CardBackProps> = ({\n  deck,\n  onClick,\n  numberOfCards,\n}) => {\n  const { getCardsByDeck } = useContext(DataContext);\n\n  if (!numberOfCards && deck) {\n    const cardsByDeck = getCardsByDeck(deck);\n    return (\n      <CardEmpty\n        title=\"Deck Empty\"\n        onReshuffle={cardsByDeck.length ? onClick : undefined}\n      />\n    );\n  }\n\n  const color = getCorrectTextColor(deck?.color || '#FFFFFF');\n  return (\n    <CardBackStyled\n      deck={deck}\n      title={deck?.title ?? ''}\n      onClick={() => onClick()}\n      textColor={color}\n    >\n      {!!deck?.description && (\n        <Text $textColor={color}>{deck.description}</Text>\n      )}\n    </CardBackStyled>\n  );\n};\n\nexport default CardBack;\n","import CardBack from './CardBackComponent';\nexport default CardBack;\n","import React from 'react';\nimport styled from 'styled-components';\nimport { Typography } from 'antd';\n\nimport CardBase from '../CardBase';\nimport CardEmpty from '../CardEmpty';\nimport { CardType } from '../../../types';\n\ninterface CardFrontStyledProps {\n  $marginTop: number;\n}\n\nconst CardFrontStyled = styled(CardBase)<CardFrontStyledProps>`\n  background: #f9fbef;\n  z-index: 2;\n  ${(props) =>\n    props.$marginTop < 0 ? `margin-top: ${props.$marginTop}px` : ''};\n`;\n\nconst Number = styled(Typography.Text)`\n  color: rgba(0, 0, 0, 0.3);\n  position: absolute;\n  top: 5px;\n  right: 5px;\n`;\nconst Text = styled(Typography.Paragraph)``;\n\ninterface CardFrontProps {\n  card?: CardType;\n  marginTop?: number;\n}\n\nconst CardFront: React.FC<CardFrontProps> = ({ card, marginTop }) => {\n  if (!card) return <CardEmpty title=\"None discarded\" marginTop={marginTop} />;\n  return (\n    <CardFrontStyled title={card?.title ?? ''} $marginTop={marginTop}>\n      <Number>#{card?.number}</Number>\n      {card?.body1 && <Text>{card?.body1}</Text>}\n      {card?.body2 && <Text>{card?.body2}</Text>}\n    </CardFrontStyled>\n  );\n};\n\nexport default CardFront;\n","import CardFront from './CardFrontComponent';\nexport default CardFront;\n","import { useEffect, useState } from 'react';\n\ninterface SizeProps {\n  width: number;\n  height: number;\n}\n\nexport const useWindowHeight = (): number => {\n  const [height, setHeight] = useState<number>(window.innerHeight);\n\n  useEffect(() => {\n    function handleResize() {\n      if (window.innerHeight === height) return;\n      setHeight(window.innerHeight);\n    }\n\n    // Add event listener\n    window.addEventListener('resize', handleResize);\n\n    // Call handler right away so state gets updated with initial window size\n    handleResize();\n\n    // Remove event listener on cleanup\n    return () => window.removeEventListener('resize', handleResize);\n  }, [height]); // Empty array ensures that effect is only run on mount\n\n  return height;\n};\n\nexport const useWindowWidth = (): number => {\n  const [width, setWidth] = useState<number>(window.innerWidth);\n\n  useEffect(() => {\n    function handleResize() {\n      if (window.innerWidth === width) return;\n      setWidth(window.innerWidth);\n    }\n\n    // Add event listener\n    window.addEventListener('resize', handleResize);\n\n    // Call handler right away so state gets updated with initial window size\n    handleResize();\n\n    // Remove event listener on cleanup\n    return () => window.removeEventListener('resize', handleResize);\n  }, [width]); // Empty array ensures that effect is only run on mount\n\n  return width;\n};\n\nexport default (): SizeProps => {\n  const height = useWindowHeight();\n  const width = useWindowWidth();\n  return { width, height };\n};\n","import React, { useState, useEffect, useContext, useCallback } from 'react';\nimport { last, random } from 'lodash';\nimport { Typography } from 'antd';\nimport styled from 'styled-components';\nimport { min, max } from 'lodash';\n\nimport DataContext from '../../data/DataContext';\n\nimport { DeckType, CardType } from '../../types';\nimport { CardFront, CardBack } from '../Card';\nimport { useWindowHeight } from '../../hooks/useWindowSize';\nimport { cardHeight } from '../../styles/theme';\n\ninterface DeckComponentsProps {\n  deck: DeckType;\n}\n\nconst TextStyled = styled(Typography.Text)`\n  -webkit-touch-callout: none;\n  -webkit-user-select: none;\n  -khtml-user-select: none;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  user-select: none;\n  position: absolute;\n  top: -5px;\n  font-size: 11px;\n`;\n\nconst Wrapper = styled.div`\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n`;\n\nconst DeckComponent: React.FC<DeckComponentsProps> = ({ deck }) => {\n  const { cards, getCardsByDeck } = useContext(DataContext);\n  const height = useWindowHeight();\n  const [cardMarginTop, setCardMarginTop] = useState<number>(0);\n\n  const [cardsInDeck, setCardsInDeck] = useState<CardType[]>([]);\n  const [cardsDiscarded, setCardsDiscarded] = useState<CardType[]>([]);\n\n  const refillDeck = useCallback(() => {\n    const cardsByDeck = getCardsByDeck(deck);\n    setCardsInDeck(cardsByDeck);\n    setCardsDiscarded([]);\n  }, [deck, getCardsByDeck]);\n\n  // Refresh the data if it changes\n  useEffect(() => {\n    refillDeck();\n  }, [cards, deck.number, refillDeck]);\n\n  const selectNextCardOrReshuffle = () => {\n    if (!cardsInDeck.length) {\n      refillDeck();\n      return;\n    }\n    const cards = [...cardsInDeck];\n    const index = random(0, cards.length);\n    const removedCards = cards.splice(index, 1);\n    if (!removedCards.length) return;\n    setCardsInDeck(cards);\n    setCardsDiscarded([...cardsDiscarded, removedCards[0]]);\n  };\n\n  useEffect(() => {\n    const idealHeight = cardHeight * 2; // Cards and margin\n    const containerHeight = height - 100 - 60;\n    if (containerHeight >= idealHeight) return;\n\n    const expectedMarginTop = containerHeight - idealHeight;\n    const withMaximum = min([expectedMarginTop, -50]) ?? cardMarginTop;\n    const withMinimum = max([withMaximum, -120]) ?? cardMarginTop;\n    if (withMinimum === cardMarginTop) return;\n\n    setCardMarginTop(withMinimum);\n  }, [cardMarginTop, height]);\n\n  return (\n    <Wrapper>\n      {!cardsDiscarded.length ? (\n        <TextStyled>{cardsInDeck.length} in deck</TextStyled>\n      ) : (\n        <TextStyled>\n          {cardsInDeck.length}/{cardsInDeck.length + cardsDiscarded.length}\n          {' - '}\n          <a onClick={refillDeck} href=\"#\">\n            reshuffle\n          </a>\n          ?\n        </TextStyled>\n      )}\n      <CardBack\n        deck={deck}\n        onClick={selectNextCardOrReshuffle}\n        numberOfCards={cardsInDeck.length}\n      />\n      <CardFront card={last(cardsDiscarded)} marginTop={cardMarginTop} />\n    </Wrapper>\n  );\n};\n\nexport default DeckComponent;\n","import DeckComponent from './DeckComponent';\nexport default DeckComponent;\n","import React from 'react';\nimport { Typography } from 'antd';\nimport styled from 'styled-components';\n\nconst NoDecksStyled = styled.div`\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n`;\n\nconst NoDecks: React.FC<any> = () => {\n  return (\n    <NoDecksStyled>\n      <Typography.Title level={3}>\n        Welcome to Deck Prototyper{' '}\n        <span role=\"img\" aria-label=\"wave\">\n          👋\n        </span>\n      </Typography.Title>\n      <Typography.Paragraph>\n        This tool has been designed to quickly create and use decks of cards for\n        prototyping your new table top game.\n      </Typography.Paragraph>\n      <Typography.Paragraph>\n        Click the cog below to upload a CSV of your cards, or click the question\n        mark to generate some random decks to get started.\n      </Typography.Paragraph>\n    </NoDecksStyled>\n  );\n};\n\nexport default NoDecks;\n","import NoDecks from './NoDecksComponent';\nexport default NoDecks;\n","import React, { useContext, useEffect, useState } from 'react';\nimport Slider from 'react-slick';\nimport { min } from 'lodash';\n\nimport DataContext from '../../data/DataContext';\nimport Deck from '../Deck';\nimport NoDecks from '../NoDecks';\nimport { DeckType } from '../../types';\nimport { useWindowWidth } from '../../hooks/useWindowSize';\nimport styled from 'styled-components';\nimport { cardWidth } from '../../styles/theme';\n\ninterface CardPreviewerProps {}\n\nconst SliderStyled = styled(Slider)`\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n`;\n\nconst CardPreviewer: React.FC<CardPreviewerProps> = () => {\n  const { decks } = useContext(DataContext);\n  const width = useWindowWidth();\n  const [toShow, setToShow] = useState<number>(3);\n\n  useEffect(() => {\n    const containerWidth = width - 100; // Remove the Layout Content padding\n    const deckWidth = cardWidth + 30; // Card plus margin between each\n    const totalDecks = decks.length;\n    const maxDecks = Math.floor(containerWidth / deckWidth);\n    const newToShow = min([totalDecks, maxDecks]);\n    if (!newToShow || newToShow === toShow) return;\n    setToShow(newToShow);\n  }, [decks.length, toShow, width]);\n\n  const settings = {\n    infinite: false,\n    dots: false,\n    speed: 500,\n    autoplay: false,\n    slidesToShow: toShow,\n    slidesToScroll: toShow,\n    initialSlide: 0,\n  };\n\n  if (!decks.length) {\n    return <NoDecks />;\n  }\n\n  return (\n    <SliderStyled {...settings}>\n      {decks.map((deck: DeckType) => {\n        return <Deck deck={deck} key={'deck' + deck.number} />;\n      })}\n    </SliderStyled>\n  );\n};\n\nexport default CardPreviewer;\n","import CardPreviewer from './CardPreviewerComponent';\nexport default CardPreviewer;\n","import React, { useContext, useState, useEffect } from 'react';\nimport { Drawer, List, Avatar, Typography, Input, message } from 'antd';\nimport { EnterOutlined } from '@ant-design/icons';\nimport { TwitterPicker } from 'react-color';\nimport styled from 'styled-components';\nimport faker from 'faker';\n\nimport { ConfigPages, DeckType } from '../../../types';\nimport DrawerContext from '../../../data/DrawerContext';\nimport DataContext from '../../../data/DataContext';\nimport { possibleDeckColors } from '../../../styles/theme';\nimport { useWindowWidth } from '../../../hooks/useWindowSize';\n\ninterface DrawerDecksProps {}\n\ninterface ColorDotProps {\n  clicked: boolean;\n  dotColor: string;\n}\n\nconst ColorPickerWrapper = styled.div`\n  position: relative;\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n`;\n\nconst ColorDotStyled = styled.div<ColorDotProps>`\n  width: 17px;\n  height: 17px;\n  border-radius: 50%;\n  cursor: pointer;\n  background-color: transparent;\n  transition: 0.2s opacity;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-content: center;\n  opacity: ${(props) => (props.clicked ? 1 : 0)};\n  background-color: ${(props) => props.dotColor};\n`;\n\nconst BlockPickerWrapper = styled.div`\n  z-index: 2;\n  position: absolute;\n  top: 30px;\n  right: -12px;\n`;\n\nconst ListItemStyled = styled(List.Item)`\n  &:hover ${ColorDotStyled} {\n    opacity: 1;\n  }\n`;\n\ninterface DeckDrawerListItemProps {\n  deck: DeckType;\n  numberColorPicker: number | null;\n  toggleNumberColorPicker: (number: number) => void;\n}\n\nconst DeckDrawerListItem: React.FC<DeckDrawerListItemProps> = ({\n  deck,\n  numberColorPicker,\n  toggleNumberColorPicker,\n}) => {\n  const [clicked, setClicked] = useState<boolean>(false);\n  const { updateDeckField, getCardsByDeck } = useContext(DataContext);\n  const totalCards = getCardsByDeck(deck);\n\n  useEffect(() => {\n    if (numberColorPicker !== deck.number) setClicked(false);\n  }, [deck.number, numberColorPicker]);\n\n  return (\n    <ListItemStyled>\n      <List.Item.Meta\n        title={\n          <Typography.Title\n            level={4}\n            editable={{\n              onChange: (value) => updateDeckField(deck.number, 'title', value),\n            }}\n          >\n            {deck.title}\n          </Typography.Title>\n        }\n        description={\n          <Typography.Text\n            editable={{\n              onChange: (value) =>\n                updateDeckField(deck.number, 'description', value),\n            }}\n          >\n            {deck.description || 'No description'}\n          </Typography.Text>\n        }\n        avatar={\n          <Avatar style={{ backgroundColor: deck.color }}>\n            {totalCards.length}\n          </Avatar>\n        }\n      />\n      <ColorPickerWrapper>\n        <ColorDotStyled\n          dotColor={deck.color ?? 'white'}\n          clicked={clicked}\n          onClick={() => {\n            setClicked(true);\n            toggleNumberColorPicker(deck.number);\n          }}\n        >\n          {/* <EditOutlined  /> */}\n        </ColorDotStyled>\n        {numberColorPicker === deck.number && (\n          <BlockPickerWrapper>\n            <TwitterPicker\n              color={deck.color ?? 'white'}\n              colors={possibleDeckColors}\n              triangle=\"top-right\"\n              width={'245px'}\n              onChange={(color) => {\n                setClicked(false);\n                toggleNumberColorPicker(deck.number);\n                updateDeckField(deck.number, 'color', color.hex);\n              }}\n            />\n          </BlockPickerWrapper>\n        )}\n      </ColorPickerWrapper>\n    </ListItemStyled>\n  );\n};\n\nconst DrawerDecks: React.FC<DrawerDecksProps> = () => {\n  const width = useWindowWidth();\n  const { pages, hasPage, togglePage } = useContext(DrawerContext);\n  const { decks, createDeck } = useContext(DataContext);\n  const [numberColorPicker, setNumberColorPicker] = useState<number | null>(\n    null\n  );\n  const [newDeck, setNewDeck] = useState<string>('');\n\n  const toggleNumberColorPicker = (no: number) => {\n    setNumberColorPicker(numberColorPicker === no ? null : no);\n  };\n\n  const addNewDeck = (e: any) => {\n    e.preventDefault();\n    const title = newDeck;\n    if (!title) {\n      message.error('Please input a deck name first');\n      return;\n    }\n    createDeck({\n      number: decks.length + 1,\n      title,\n      color: faker.random.arrayElement(possibleDeckColors),\n      description: '',\n    });\n    setNewDeck('');\n  };\n\n  return (\n    <Drawer\n      title=\"Decks\"\n      placement=\"left\"\n      width={width < 680 ? '95%' : '40%'}\n      closable={true}\n      visible={hasPage(ConfigPages.DECKS)}\n      onClose={() => togglePage(ConfigPages.DECKS)}\n      maskClosable={false}\n      mask={pages.length < 2}\n    >\n      <List\n        dataSource={decks}\n        renderItem={(deck: DeckType) => (\n          <DeckDrawerListItem\n            deck={deck}\n            numberColorPicker={numberColorPicker}\n            toggleNumberColorPicker={toggleNumberColorPicker}\n          />\n        )}\n        footer={\n          <Input\n            value={newDeck}\n            onChange={(e) => setNewDeck(e.target.value)}\n            placeholder=\"Add new deck\"\n            addonAfter={<EnterOutlined />}\n            onPressEnter={addNewDeck}\n          />\n        }\n      />\n    </Drawer>\n  );\n};\n\nexport default DrawerDecks;\n","import DecksDrawer from './DecksDrawerComponent';\nexport default DecksDrawer;\n","import React, { useContext, useState } from 'react';\nimport { Drawer, Table, Tag, Typography, Input } from 'antd';\nimport { MinusCircleOutlined, PlusCircleOutlined } from '@ant-design/icons';\nimport styled, { DefaultTheme } from 'styled-components';\n\nimport { ConfigPages, CardType, CardDecks, DeckType } from '../../../types';\nimport DataContext from '../../../data/DataContext';\nimport DrawerContext from '../../../data/DrawerContext';\nimport { getCorrectTextColor } from '../../../utils/color';\n\ninterface TagStyledProps {\n  $textColor: string;\n  theme: DefaultTheme;\n}\n\nconst TagStyled = styled(Tag)<TagStyledProps>`\n  clear: both;\n  float: left;\n  margin-bottom: 5px;\n  color: ${(props) => props.$textColor};\n\n  .ant-tag-close-icon {\n    font-size: 12px;\n    margin-left: 7px;\n    color: ${(props) => props.$textColor};\n  }\n`;\n\nconst SearchStyled = styled(Input.Search)`\n  width: 200px;\n  float: right;\n  margin-bottom: 15px;\n`;\n\ninterface DrawerDecksProps {}\n\nconst DrawerData: React.FC<DrawerDecksProps> = () => {\n  const [searchQuery, setSearchQuery] = useState<string>('');\n  const { cards, decks, updateCardField } = useContext(DataContext);\n  const { pages, hasPage, togglePage } = useContext(DrawerContext);\n\n  // const getCardDeckData = (deckData: CardDecks): DeckType[] => {\n  //   // @ts-ignore\n  //   return Object.keys(deckData)\n  //     .map((deckId) => {\n  //       const total = deckData[parseInt(deckId)];\n  //       const deck = findDeck(parseInt(deckId));\n  //       if (!deck) return null;\n  //       return {\n  //         ...deck,\n  //         title: `${deck.title} (${total})`,\n  //       } as DeckType;\n  //     })\n  //     .filter(Boolean);\n  // };\n\n  const removeFromDeck = (e: any, card: CardType, deck: DeckType) => {\n    e.preventDefault();\n    const decks = { ...card.decks };\n    if (!decks[deck.number] || decks[deck.number] === 1) {\n      delete decks[deck.number];\n    } else {\n      decks[deck.number] = decks[deck.number] - 1;\n    }\n    updateCardField(card.number, 'decks', decks);\n  };\n\n  const addToDeck = (e: any, card: CardType, deck: DeckType) => {\n    e.preventDefault();\n    const decks = { ...card.decks };\n    if (!decks[deck.number] || decks[deck.number] === 0) {\n      decks[deck.number] = 1;\n    } else {\n      decks[deck.number] = decks[deck.number] + 1;\n    }\n    updateCardField(card.number, 'decks', decks);\n  };\n\n  const columns = [\n    {\n      title: 'ID',\n      dataIndex: 'number',\n      render: (id: number) => `#${id.toString()}`,\n    },\n    {\n      title: 'title',\n      dataIndex: 'title',\n      render: (title: string, card: CardType) => (\n        <Typography.Text\n          editable={{\n            onChange: (value) => updateCardField(card.number, 'title', value),\n          }}\n        >\n          {title}\n        </Typography.Text>\n      ),\n    },\n    {\n      title: 'Body 1',\n      dataIndex: 'body1',\n      render: (body1: string, card: CardType) => (\n        <Typography.Text\n          editable={{\n            onChange: (value) => updateCardField(card.number, 'body1', value),\n          }}\n        >\n          {body1}\n        </Typography.Text>\n      ),\n    },\n    {\n      title: 'Body 2',\n      dataIndex: 'body2',\n      render: (body2: string, card: CardType) => (\n        <Typography.Text\n          editable={{\n            onChange: (value) => updateCardField(card.number, 'body2', value),\n          }}\n        >\n          {body2}\n        </Typography.Text>\n      ),\n    },\n    {\n      title: 'Decks',\n      dataIndex: 'decks',\n      render: (deckNumbers: CardDecks, card: CardType) => {\n        return (\n          <>\n            {decks.map((deck) => {\n              if (!deck.title) return null;\n              const textColor = getCorrectTextColor(deck.color);\n              const total = card.decks[deck.number] ?? 0;\n              return (\n                <TagStyled\n                  icon={\n                    <MinusCircleOutlined\n                      onClick={(e) => removeFromDeck(e, card, deck)}\n                    />\n                  }\n                  closeIcon={<PlusCircleOutlined color={'white'} />}\n                  color={deck?.color}\n                  $textColor={textColor}\n                  key={card.number + 'tag' + deck?.number}\n                  closable={true}\n                  onClose={(e: any) => addToDeck(e, card, deck)}\n                >\n                  {deck.title.toUpperCase()} ({total})\n                </TagStyled>\n              );\n            })}\n          </>\n        );\n      },\n    },\n  ];\n\n  const searchedCards = cards.filter((card) => {\n    if (!card) return false;\n    if (!searchQuery) return true;\n    const regex = new RegExp(searchQuery, 'ig');\n    return (\n      regex.test(card.number.toString() ?? '') ||\n      regex.test('#' + card.number.toString() ?? '') ||\n      regex.test(card.title ?? '') ||\n      regex.test(card.body1 ?? '') ||\n      regex.test(card.body2 ?? '')\n    );\n  });\n\n  return (\n    <Drawer\n      title=\"Cards\"\n      placement=\"right\"\n      width={'95%'}\n      closable={true}\n      visible={hasPage(ConfigPages.DATA)}\n      onClose={() => togglePage(ConfigPages.DATA)}\n      maskClosable={false}\n      mask={pages.length < 2}\n    >\n      <SearchStyled\n        placeholder=\"Search cards\"\n        onSearch={(value) => setSearchQuery(value)}\n        allowClear={true}\n      />\n      <div style={{ clear: 'both' }} />\n      <Table columns={columns} dataSource={searchedCards} />\n    </Drawer>\n  );\n};\n\nexport default DrawerData;\n","import DrawerCards from './CardsDrawerComponent';\nexport default DrawerCards;\n","import { useState, useContext } from 'react';\nimport Papa from 'papaparse';\nimport { without, uniq } from 'lodash';\nimport faker from 'faker';\n\nimport { saveCards } from '../data/queries/cards';\nimport { saveDecks } from '../data/queries/decks';\nimport { DeckType, CardType, CardDecks } from '../types';\nimport DataContext from '../data/DataContext';\nimport { possibleDeckColors } from '../styles/theme';\n\nconst expectedFields = ['number', 'title', 'body1', 'body2', 'decks'];\nconst requiredFields = ['number', 'title'];\n\ninterface PapaParseDataType {\n  number: string;\n  title?: string;\n  body1?: string;\n  body2?: string;\n  decks: string;\n}\n\ninterface CardTypeWithStringDecks {\n  number: number;\n  title?: string;\n  body1?: string;\n  body2?: string;\n  decks: string[];\n}\n\ninterface UseImportOutput {\n  importFile: (file: File) => void;\n  importing: boolean;\n}\n\n/**\n * Parse the CSV file to date we need\n * @param file\n */\nconst parseCSV = (file: File): Promise<Papa.ParseResult<PapaParseDataType>> => {\n  return new Promise((resolve, reject) => {\n    Papa.parse(file, {\n      skipEmptyLines: true,\n      header: true,\n      complete: resolve,\n      error: reject,\n    });\n  });\n};\n\n/**\n * Validate the fields in the data returned to make sure all the headers are present\n * @param results\n */\nconst validateFields = (\n  results: Papa.ParseResult<PapaParseDataType>\n): Papa.ParseResult<PapaParseDataType> => {\n  if (!results || !results.data) {\n    throw new Error('No data in the file');\n  }\n\n  // Make sure the expected headers are present\n  const headers = results.meta.fields;\n  const missingHeaders = without(expectedFields, ...headers);\n  if (missingHeaders.length) {\n    throw new Error(\n      `Missing the following fields: ${missingHeaders.join(', ')}`\n    );\n  }\n\n  // Make sure the required fields have content\n  results.data.forEach((row: PapaParseDataType) => {\n    requiredFields.forEach((field: string) => {\n      // @ts-ignore\n      if (!(row[field] ?? '')) {\n        throw new Error(\n          `Missing any content for the '${field}' field on one of the rows`\n        );\n      }\n    });\n  });\n\n  return results;\n};\n\n/**\n * Format the cards to be a format we can use\n * @param cards\n */\nconst formatCards = (cards: PapaParseDataType[]): CardTypeWithStringDecks[] => {\n  return cards.map((card: any) => ({\n    number: parseInt(card.number),\n    title: card.title,\n    body1: card.body1 ?? '',\n    body2: card.body2 ?? '',\n    decks: (card.decks ?? '').split(',').filter(Boolean),\n  }));\n};\n\n/**\n * Make sure that all the rows in a CSV file has a unique number\n * @param cards\n */\nconst checkUniqueIds = (cards: CardTypeWithStringDecks[]) => {\n  const allIds = cards.map((c) => c.number);\n  const uniqueIds = uniq(allIds);\n  if (uniqueIds.length === allIds.length) return;\n  throw new Error('Each row does not have its own unqiue number');\n};\n\n/**\n * Hook to import data into the app\n */\nconst useImport = (): UseImportOutput => {\n  const { refetchFromLocalStorage, changeHasImported } = useContext(\n    DataContext\n  );\n  const [importing, setImporting] = useState(false);\n\n  /**\n   * Create an array of decks from the cards that are being imported\n   * @param cards\n   */\n  const createDecksFromImportedCards = (\n    cards: CardTypeWithStringDecks[]\n  ): DeckType[] => {\n    const deckNames: string[] = cards.reduce(\n      (all: string[], card: CardTypeWithStringDecks) => {\n        card.decks.forEach((deck: string) => {\n          const deckName = deck.split('|')[0];\n          if (!all.includes(deckName)) all.push(deckName);\n        });\n        return all;\n      },\n      []\n    );\n    const deckData: DeckType[] = [];\n    const usedColors: string[] = [];\n    deckNames.forEach((title, i) => {\n      const color = faker.random.arrayElement(\n        without(possibleDeckColors, ...usedColors)\n      );\n      usedColors.push(color);\n      deckData.push({\n        number: i + 1,\n        title,\n        description: '',\n        color,\n      });\n    });\n    return deckData;\n  };\n\n  /**\n   * Save cards and decks to the local storage\n   * @param decks\n   * @param cards\n   */\n  const saveDecksAndCards = (\n    decks: DeckType[],\n    cards: CardTypeWithStringDecks[]\n  ) => {\n    const cardData: CardType[] = cards.map((card: CardTypeWithStringDecks) => {\n      const decksRelationship: CardDecks = {};\n      card.decks.forEach((deckNameAndNumber: string) => {\n        if (!deckNameAndNumber) return;\n        let [deckName, total = 1] = deckNameAndNumber.split('|');\n        const deckData = decks.find((d) => d.title === deckName);\n        if (!deckData) return;\n        // @ts-ignore\n        decksRelationship[deckData.number] = parseInt(total);\n      });\n      return {\n        ...card,\n        decks: decksRelationship,\n      } as CardType;\n    });\n\n    saveCards(cardData);\n    saveDecks(decks);\n  };\n\n  const importFile = async (file: File): Promise<void> => {\n    setImporting(true);\n    try {\n      const results = await parseCSV(file);\n      const validatedData = validateFields(results);\n      const cards = formatCards(validatedData.data);\n      checkUniqueIds(cards);\n      const decks = createDecksFromImportedCards(cards);\n      saveDecksAndCards(decks, cards);\n      refetchFromLocalStorage();\n      changeHasImported(true);\n      setImporting(false);\n    } catch (e) {\n      console.error(e);\n      setImporting(false);\n      throw e;\n    }\n  };\n\n  return { importFile, importing };\n};\n\nexport default useImport;\n","import { useContext, useState } from 'react';\nimport Papa from 'papaparse';\n\nimport DataContext from '../data/DataContext';\nimport { CardDecks } from '../types';\n\ninterface UseExportOutput {\n  exportData: () => Promise<void>;\n  exporting: boolean;\n}\n\n/**\n * Take the deck Ids and transform them into a string\n * @param deckData\n * @param getCardDeckNames\n */\nconst transformCardDecksToString = (\n  deckData: CardDecks,\n  getCardDeckNames: (decks: number[]) => string[]\n) => {\n  return Object.keys(deckData)\n    .map((deckId) => {\n      const total = deckData[parseInt(deckId)];\n      const [name] = getCardDeckNames([parseInt(deckId)]);\n      if (!name) return '';\n      return `${name}|${total}`;\n    })\n    .filter(Boolean)\n    .join(',');\n};\n\n/**\n * Hook to export data from the app\n */\nconst useExport = (): UseExportOutput => {\n  const { cards, getCardDeckNames } = useContext(DataContext);\n  const [exporting, setExporting] = useState(false);\n\n  const exportData = async () => {\n    setExporting(true);\n\n    // const decksContent = Papa.unparse(decks);\n\n    const cardsContent = Papa.unparse(\n      cards.map((card) => ({\n        ...card,\n        decks: transformCardDecksToString(card.decks, getCardDeckNames),\n      }))\n    );\n\n    const prefix = 'data:text/csv;charset=utf-8,';\n\n    // const encodedDeckUri = encodeURI(prefix + decksContent);\n    // window.open(encodedDeckUri);\n    const encodedCardsUri = encodeURI(prefix + cardsContent);\n    window.open(encodedCardsUri);\n    setExporting(false);\n  };\n\n  return { exportData, exporting };\n};\n\nexport default useExport;\n","import React, { useContext, useState } from 'react';\nimport { Modal, Upload, message, Divider, Typography, Button } from 'antd';\nimport { ImportOutlined } from '@ant-design/icons';\n\nimport { ConfigPages } from '../../types';\nimport DrawerContext from '../../data/DrawerContext';\n\nimport useImport from '../../hooks/useImport';\nimport useExport from '../../hooks/useExport';\nimport styled from 'styled-components';\n\ninterface SettingsProps {}\n\nconst FooterText = styled(Typography.Paragraph)`\n  text-align: center;\n  margin-bottom: 0;\n`;\n\nconst Settings: React.FC<SettingsProps> = () => {\n  const { hasPage, togglePage } = useContext(DrawerContext);\n  const { importFile } = useImport();\n  const { exportData } = useExport();\n  const [showMore, setShowMore] = useState<boolean>(false);\n\n  const handleExport = async (e: any) => {\n    e.preventDefault();\n    try {\n      await exportData();\n      message.success('Settings exported successfully.');\n      return false;\n    } catch (e) {\n      message.error(e.message);\n      return false;\n    }\n  };\n\n  const handleImport = async (info: any) => {\n    try {\n      await importFile(info.file);\n      message.success('File imported');\n      info.onSuccess('ok');\n    } catch (e) {\n      message.error(e.message);\n      info.onError(e);\n    }\n  };\n\n  return (\n    <Modal\n      title=\"Import/Export data\"\n      visible={hasPage(ConfigPages.SETTINGS)}\n      onOk={() => togglePage(ConfigPages.SETTINGS)}\n      onCancel={() => togglePage(ConfigPages.SETTINGS)}\n      footer={\n        <FooterText>\n          Made with{' '}\n          <span role=\"img\" aria-label=\"heart\">\n            ♥️\n          </span>{' '}\n          by{' '}\n          <a\n            target=\"_blank\"\n            href=\"https://github.com/owenr88\"\n            rel=\"noopener noreferrer\"\n          >\n            Owen\n          </a>\n        </FooterText>\n      }\n    >\n      <Upload.Dragger\n        accept=\".csv\"\n        name=\"file\"\n        multiple={false}\n        customRequest={handleImport}\n        showUploadList={false}\n      >\n        <p className=\"ant-upload-drag-icon\">\n          <ImportOutlined />\n        </p>\n        <p className=\"ant-upload-text\">\n          Click or drag a file to this area to upload it\n        </p>\n        <p className=\"ant-upload-hint\">\n          CSV supported only. See the link below for a template of how to format\n          the CSV.\n        </p>\n      </Upload.Dragger>\n      <Typography.Paragraph style={{ marginTop: 24 }}>\n        Download the{' '}\n        <a\n          href={process.env.PUBLIC_URL + '/sample.csv'}\n          download=\"deck-prototyper-sample\"\n        >\n          sample CSV\n        </a>{' '}\n        file to get a feel for the data structure.{' '}\n        <a href=\"#\" onClick={() => setShowMore(true)}>\n          More info\n        </a>\n      </Typography.Paragraph>\n      {showMore && (\n        <>\n          <Typography.Paragraph>\n            * Only the number (card ID) and title are required to be filled for\n            each card, but all fields must be present.\n          </Typography.Paragraph>\n          <Typography.Paragraph>\n            * The number (card ID) must be unique for every card/row.\n          </Typography.Paragraph>\n          <Typography.Paragraph>\n            * The decks field is a comma separated list of deck names, which can\n            use an optional pipe (\"|\") to define the total number of this card\n            included in a deck. For example a 'decks' field with \"Action Deck|4\"\n            will mean that 4 of that card will be inserted into the \"Action\n            Deck\". See the sample CSV above as an example.\n          </Typography.Paragraph>\n        </>\n      )}\n      <Divider />\n      <Typography.Paragraph>\n        You can re-import your exported settings at any time. All your data is\n        stored locally in your browser, not on a remote server.{' '}\n        <b>\n          If you clear your cookies or site settings you will lose your data, so\n          make sure have a back up.\n        </b>\n      </Typography.Paragraph>\n      <Button type=\"primary\" onClick={handleExport}>\n        Export data\n      </Button>\n    </Modal>\n  );\n};\n\nexport default Settings;\n","import Settings from './SettingsComponent';\nexport default Settings;\n","import React from 'react';\nimport { Layout } from 'antd';\nimport styled from 'styled-components';\nimport chroma from 'chroma-js';\n\nimport Nav from '../../components/Nav';\nimport CardPreviewer from '../../components/CardPreviewer';\nimport { DecksDrawer, CardsDrawer } from '../../components/Drawer';\nimport Settings from '../../components/Settings';\n\nconst Page = styled(Layout)`\n  min-height: 100vh;\n  ${(props) => {\n    const colors = props.theme.colors.gradientColors;\n\n    const col1 = chroma(colors[0]).rgb().join(',');\n    const col2 = chroma(colors[1]).rgb().join(',');\n    const col3 = chroma(colors[2]).rgb().join(',');\n    const col4 = chroma(colors[3]).rgb().join(',');\n\n    return `\n    background:\n      -webkit-linear-gradient(315deg, rgba(${col1}, 1) 0%, rgba(${col1}, 0) 70%),\n      -webkit-linear-gradient(65deg, rgba(${col2}, 1) 10%, rgba(${col2}, 0) 80%),\n      -webkit-linear-gradient(135deg, rgba(${col3}, 1) 15%, rgba(${col3}, 0) 80%),\n      -webkit-linear-gradient(205deg, rgba(${col4}, 1) 100%, rgba(${col4}, 0) 70%);\n    background:\n      linear-gradient(315deg, rgba(${col1}, 1) 0%, rgba(${col1}, 0) 70%),\n      linear-gradient(65deg, rgba(${col2}, 1) 10%, rgba(${col2}, 0) 80%),\n      linear-gradient(135deg, rgba(${col3}, 1) 15%, rgba(${col3}, 0) 80%),\n      linear-gradient(205deg, rgba(${col4}, 1) 100%, rgba(${col4}, 0) 70%);\n    `;\n  }}\n`;\n\nconst Container = styled(Layout.Content)`\n  padding: 50px;\n  text-align: center;\n  display: flex;\n  flex-direction: row;\n  justify-content: center;\n  align-content: center;\n`;\n\nfunction App() {\n  return (\n    <Page>\n      <Container>\n        <Nav />\n        <CardPreviewer />\n        <DecksDrawer />\n        <CardsDrawer />\n        <Settings />\n      </Container>\n    </Page>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { ThemeProvider } from 'styled-components';\n\nimport './styles/app.less';\nimport 'slick-carousel/slick/slick.css';\nimport 'slick-carousel/slick/slick-theme.css';\n\nimport theme from './styles/theme';\nimport { DataContextProvider } from './data/DataContext';\nimport { DrawerContextProvider } from './data/DrawerContext';\n\nimport App from './scenes/Main/MainScene';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <ThemeProvider theme={theme}>\n      <DataContextProvider>\n        <DrawerContextProvider>\n          <App />\n        </DrawerContextProvider>\n      </DataContextProvider>\n    </ThemeProvider>\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","module.exports = {\n  'primary': '#07d514',\n  'secondary': '#098BE1',\n  \n  'lightBlue': '#01c4d6',\n  'blue': '#0485F7',\n  'lightOrange': '#FFC200',\n  'orange': '#FF9500',\n  'red': '#FF4F00',\n}"],"sourceRoot":""}